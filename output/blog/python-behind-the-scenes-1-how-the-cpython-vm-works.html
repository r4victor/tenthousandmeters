<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <meta name="generator" content="Pelican" />
        <title>Python behind the scenes #1: how the CPython VM works</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="Have you ever wondered what python does when you run one of your programs? $ python script.py This article opens a series which seeks to answer..." />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">Ten thousand meters</a></h1>
                <div class='subtitle'>Diving deep, flying high to see why</div>
                <nav><ul>
                    <li><a href="/about/">about</a></li>
                    <li><a href="/">blog</a></li>
                    <li><a href="/materials/">materials</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/blog/python-behind-the-scenes-1-how-the-cpython-vm-works/" rel="bookmark"
           title="Permalink to Python behind the scenes #1: how the CPython VM works">Python behind the scenes #1: how the CPython VM works</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2020-08-31T10:21:00+01:00">
                Published: Mon 31 August 2020
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/about/">Victor Skvortsov</a>
        </address>
<p>tags: <a href="/tag/python-behind-the-scenes/">Python behind the scenes</a> <a href="/tag/python/">Python</a> <a href="/tag/cpython/">CPython</a> </p>
</footer><!-- /.post-info -->      <h2>Introduction</h2>
<p>Have you ever wondered what <code>python</code> does when you run one of your programs?</p>
<div class="highlight"><pre><span></span>$ python script.py 
</pre></div>


<p>This article opens a series which seeks to answer this very question. We'll dive into the internals of CPython, Python's most popular implementation. By doing so we'll understand the language itself at a deeper level. That is the primary goal of this series. If you're familiar with Python and comfortable reading C but have no much experience working with CPython's source code, there is a good chance you'll find this writing interesting.</p>
<h3>What CPython is and why anyone would want to study it</h3>
<p>Let's begin by stating some well-known facts. CPython is a Python interpreter written in C. It's one of the Python implementations, alongside with PyPy, Jython, IronPython and many others. CPython is distinguished in that it is original, most-maintained and the most popular one.</p>
<p>CPython implements Python, but what is Python? One may simply answer – Python is a programming language. The answer becomes much more nuanced when the same question is put properly: what defines what Python is? Python, unlike languages like C, doesn't have a formal specification. The thing that comes closest to it is the <a href="https://docs.python.org/3.9/reference/index.html">Python Language Reference</a> which starts with the following words:</p>
<blockquote>
<p>While I am trying to be as precise as possible, I chose to use English rather than formal specifications for everything except syntax and lexical analysis. This should make the document more understandable to the average reader, but will leave room for ambiguities. Consequently, if you were coming from Mars and tried to re-implement Python from this document alone, you might have to guess things and in fact you would probably end up implementing quite a different language. On the other hand, if you are using Python and wonder what the precise rules about a particular area of the language are, you should definitely be able to find them here.</p>
</blockquote>
<p>So Python is not defined by its language reference only. It would be also wrong to say that Python is defined by its reference implementation, CPython, since there are some implementation details that are not a part of the language. A garbage collector that relies on a reference counting is one example. Since there is no single source of truth, we may say that Python is defined partly by the Python Language Reference and partly by its main implementation, CPython.</p>
<p>Such a reasoning may seem pedantic, but I think it is crucial to clarify the key role of the subject we're going to study. You might still wonder, though, why we should study it. Besides plain curiosity, I see the following reasons:</p>
<ul>
<li>Having a full picture gives a deeper understanding of the language. It's much more easier to grasp some peculiarity of Python if you're aware of its implementation details.</li>
<li>Implementation details matter in practice. How objects are stored, how the garbage collector works and how multiple threads are coordinated are subjects of high importance when one wants to understand the of applicability of the language and its limitations, estimate performance or detect inefficiencies.</li>
<li>CPython provides Python/C API which allows to extend Python with C and embed Python inside C. To use this API effectively a programmer needs a good understanding of how CPython works.</li>
</ul>
<h3>What it takes to understand how CPython works</h3>
<p>CPython was designed to be easy to maintain. A newcomer can certainly expect to be able to read the source code and understand what it does. However, it may take some time. By writing this series I hope to help you to shorten it. </p>
<h3>How this series is laid out</h3>
<p>I chose to take a top-down approach. In this part we'll explore the core concepts of the CPython virtual machine (VM). Next, we'll see how CPython compiles a program into something that the VM can execute. After that, we'll get familiar with the source code and step through the execution of a program studying main parts of the interpreter on the way. Eventually, we'll be able to pick out different aspects of the language one by one and see how they're implemented. This is by no way a strict plan but my approximate idea.</p>
<p><strong>Note</strong>: In this post I'm referring to CPython 3.9. Some implementation details will certainly change as CPython evolves. I'll try to keep track of important changes and add update notes.</p>
<h2>The big picture</h2>
<p>An execution of a Python program roughly consists of three stages:</p>
<ol>
<li>Initialization</li>
<li>Compilation</li>
<li>Interpretation</li>
</ol>
<p>During initialization stage, CPython initializes data structures required to run Python. It also prepares such things as builtin types, configures and loads builtin modules, sets up the import system and does many other things. This is very important stage that is often overlooked by the CPython's explorers because of its service nature.</p>
<p>Next comes the compilation stage. CPython is an interpreter, not a compiler in a sense that it doesn't produce machine code. Interpreters, however, usually translate source code into some intermediate representation before executing it. So does CPython. This translation phase does the same things a typical compiler does: parses a source code and builds an AST (Abstract Syntax Tree), generates bytecode from an AST and even performs some bytecode optimizations.</p>
<p>Before looking at the next stage, we need to understand what bytecode is. Bytecode is a series of instructions. Each instruction consists of two bytes: one for an opcode and one for an argument. Consider an example:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">3</span>
</pre></div>


<p>CPython translates the body of the function <code>g</code> to the following sequence of bytes: <code>[124, 0, 100, 1, 23, 0, 83, 0]</code>. If we run a standard <code>dis</code> module to disassemble it, here's what we'll get:</p>
<div class="highlight"><pre><span></span><span class="mi">2</span>           <span class="mi">0</span> <span class="n">LOAD_FAST</span>            <span class="mi">0</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="mi">2</span> <span class="n">LOAD_CONST</span>           <span class="mi">1</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="mi">4</span> <span class="n">BINARY_ADD</span>
            <span class="mi">6</span> <span class="n">RETURN_VALUE</span>
</pre></div>


<p><code>LOAD_FAST</code> opcode corresponds to a byte <code>124</code> and has an argument <code>0</code>. <code>LOAD_CONST</code> opcode corresponds to a byte <code>100</code> and has an argument <code>1</code>. <code>BINARY_ADD</code> and <code>RETURN_VALUE</code> instructions are always encoded as <code>(23, 0)</code> and <code>(83, 0)</code> respectively since they don't need an argument.</p>
<p>At the heart of CPython is a virtual machine that executes bytecode. By looking at the previous example you might guess how it works. CPython's VM is stack-based. It means that it executes instructions using the stack to store and retrieve data. <code>LOAD_FAST</code> instruction pushes local variable on the stack. <code>LOAD_CONST</code> pushes a constant. <code>BINARY_ADD</code> pops two objects from the stack, adds them up and pushes the result back. Finally, <code>RETURN_VALUE</code> pops whatever is on the stack and returns the result to its caller.</p>
<p>The bytecode execution happens in a giant evaluation loop that runs while there are instructions to execute. It stops to yield a value or if an error occured.</p>
<p>Such a brief overview gives rise to a lot of questions:</p>
<ul>
<li>What do the arguments to the opcodes <code>LOAD_FAST</code> and <code>LOAD_CONST</code> mean? Are they indices? What do they index?</li>
<li>Does the VM places values or references to the objects on the stack?</li>
<li>How does CPython know that <code>x</code> is a local variable?</li>
<li>What if an argument is too big to fit into a single byte?</li>
<li>Is instruction for adding up two numbers the same as for concatenating two strings? If yes, then how does the VM differentiate between these operations?</li>
</ul>
<p>In order to answer these and other intriguing questions we need to look at the core concepts of the CPython VM.</p>
<h3>Code objects, function objects, frames</h3>
<h4>code object</h4>
<p>We saw what bytecode of a simple function looks like. But a typical Python program is more complicated. How does the VM execute a module that contains function definitions and make function calls?</p>
<p>Consider a program:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</pre></div>


<p>What does its bytecode look like? To answer this question, let's analyze what the program does. It defines a function <code>f</code>, calls function <code>f</code> with <code>1</code> as an argument and prints the result of the call. Whatever the function <code>f</code> does, it's not a part of the module's bytecode. We can assure ourselves by running a disassembler.</p>
<div class="highlight"><pre><span></span><span class="mi">1</span>           <span class="mi">0</span> <span class="n">LOAD_CONST</span>               <span class="mi">0</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">code</span> <span class="k">object</span> <span class="n">f</span> <span class="k">at</span> <span class="mi">0</span><span class="n">x10bffd1e0</span><span class="p">,</span> <span class="n">file</span> <span class="ss">&quot;example.py&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">)</span>
            <span class="mi">2</span> <span class="n">LOAD_CONST</span>               <span class="mi">1</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
            <span class="mi">4</span> <span class="n">MAKE_FUNCTION</span>            <span class="mi">0</span>
            <span class="mi">6</span> <span class="n">STORE_NAME</span>               <span class="mi">0</span> <span class="p">(</span><span class="n">f</span><span class="p">)</span>

<span class="mi">4</span>           <span class="mi">8</span> <span class="n">LOAD_NAME</span>                <span class="mi">1</span> <span class="p">(</span><span class="n">print</span><span class="p">)</span>
           <span class="mi">10</span> <span class="n">LOAD_NAME</span>                <span class="mi">0</span> <span class="p">(</span><span class="n">f</span><span class="p">)</span>
           <span class="mi">12</span> <span class="n">LOAD_CONST</span>               <span class="mi">2</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
           <span class="mi">14</span> <span class="n">CALL_FUNCTION</span>            <span class="mi">1</span>
           <span class="mi">16</span> <span class="n">CALL_FUNCTION</span>            <span class="mi">1</span>
           <span class="mi">18</span> <span class="n">POP_TOP</span>
           <span class="mi">20</span> <span class="n">LOAD_CONST</span>               <span class="mi">3</span> <span class="p">(</span><span class="k">None</span><span class="p">)</span>
           <span class="mi">22</span> <span class="n">RETURN_VALUE</span>
</pre></div>


<p>On line one we define function <code>f</code> by making a function from something called code object and binding name <code>f</code> to it. We don't see the bytecode of the function <code>f</code> that returns an incremented argument.</p>
<p>The pieces of code that are executed as a single unit like a module or a function body are called code blocks. CPython stores information about what a code block does in a structure called code object. It contains the bytecode and such things as lists of names of variables used within the block. To run a module or to call a function means to start evaluating a corresponding code object.</p>
<h4>function object</h4>
<p>A function, however, is not merely a code object. It must include additional information such as name, docstring, default arguments and values of variables defined in the enclosing scope. This information, together with a code object, is stored inside a function object. <code>MAKE_FUNCTION</code> instruction is used to create it. The definition of the function object structure in the CPython source code is preceeded by the following comment:</p>
<blockquote>
<p>Function objects and code objects should not be confused with each other:</p>
<p>Function objects are created by the execution of the 'def' statement. They reference a code object in their __code__ attribute, which is a purely syntactic object, i.e. nothing more than a compiled version of some source code lines.  There is one code object per source code "fragment", but each code object can be referenced by zero or many function objects depending only on how many times the 'def' statement in the source was executed so far.</p>
</blockquote>
<p>How can it be that several function objects reference a single code object? Here is an example:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_add_x</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">add_x</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">return</span> <span class="n">add_x</span>

<span class="n">add_4</span> <span class="o">=</span> <span class="n">make_add_x</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">add_5</span> <span class="o">=</span> <span class="n">make_add_x</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>


<p>The bytecode of the <code>make_add_x</code> function contains a <code>MAKE_FUNCTION</code> instruction. The functions <code>add_4</code> and <code>add_5</code> are the result of calling this instruction with the same code object as an argument. But there is one argument that differs – the value of <code>x</code>. Each function gets its own by the mechanism of cell variables that allows us to create closures like <code>add_4</code> and <code>add_5</code>. </p>
<p>I recommend you to take a look at the definitions of the code and function objects before we move to the next concept.</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">PyCodeObject</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="kt">int</span> <span class="n">co_argcount</span><span class="p">;</span>            <span class="cm">/* #arguments, except *args */</span>
    <span class="kt">int</span> <span class="n">co_posonlyargcount</span><span class="p">;</span>     <span class="cm">/* #positional only arguments */</span>
    <span class="kt">int</span> <span class="n">co_kwonlyargcount</span><span class="p">;</span>      <span class="cm">/* #keyword only arguments */</span>
    <span class="kt">int</span> <span class="n">co_nlocals</span><span class="p">;</span>             <span class="cm">/* #local variables */</span>
    <span class="kt">int</span> <span class="n">co_stacksize</span><span class="p">;</span>           <span class="cm">/* #entries needed for evaluation stack */</span>
    <span class="kt">int</span> <span class="n">co_flags</span><span class="p">;</span>               <span class="cm">/* CO_..., see below */</span>
    <span class="kt">int</span> <span class="n">co_firstlineno</span><span class="p">;</span>         <span class="cm">/* first source line number */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_code</span><span class="p">;</span>          <span class="cm">/* instruction opcodes */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_consts</span><span class="p">;</span>        <span class="cm">/* list (constants used) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_names</span><span class="p">;</span>         <span class="cm">/* list of strings (names used) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_varnames</span><span class="p">;</span>      <span class="cm">/* tuple of strings (local variable names) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_freevars</span><span class="p">;</span>      <span class="cm">/* tuple of strings (free variable names) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_cellvars</span><span class="p">;</span>      <span class="cm">/* tuple of strings (cell variable names) */</span>

    <span class="n">Py_ssize_t</span> <span class="o">*</span><span class="n">co_cell2arg</span><span class="p">;</span>    <span class="cm">/* Maps cell vars which are arguments. */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_filename</span><span class="p">;</span>      <span class="cm">/* unicode (where it was loaded from) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">co_name</span><span class="p">;</span>          <span class="cm">/* unicode (name, for reference) */</span>
        <span class="cm">/* ... more members ... */</span>
<span class="p">};</span>
</pre></div>


<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_HEAD</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func_code</span><span class="p">;</span>        <span class="cm">/* A code object, the __code__ attribute */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func_globals</span><span class="p">;</span>     <span class="cm">/* A dictionary (other mappings won&#39;t do) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func_defaults</span><span class="p">;</span>    <span class="cm">/* NULL or a tuple */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func_kwdefaults</span><span class="p">;</span>  <span class="cm">/* NULL or a dict */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func_closure</span><span class="p">;</span>     <span class="cm">/* NULL or a tuple of cell objects */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func_doc</span><span class="p">;</span>         <span class="cm">/* The __doc__ attribute, can be anything */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func_name</span><span class="p">;</span>        <span class="cm">/* The __name__ attribute, a string object */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func_dict</span><span class="p">;</span>        <span class="cm">/* The __dict__ attribute, a dict or NULL */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func_weakreflist</span><span class="p">;</span> <span class="cm">/* List of weak references */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func_module</span><span class="p">;</span>      <span class="cm">/* The __module__ attribute, can be anything */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func_annotations</span><span class="p">;</span> <span class="cm">/* Annotations, a dict or NULL */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func_qualname</span><span class="p">;</span>    <span class="cm">/* The qualified name */</span>
    <span class="n">vectorcallfunc</span> <span class="n">vectorcall</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PyFunctionObject</span><span class="p">;</span>
</pre></div>


<h4>frame object</h4>
<p>When executing a code object, the VM has to keep track of the values of variables and the constantly changing value stack. It also needs to remember where it stopped executing the current code object to execute another and where to go on return. CPython stores this information inside a frame object, or simply a frame. A frame provides a state in which a code object can be executed. Since we're getting more accustomed with the source code, I leave the definition of the frame object here as well:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">_frame</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="k">struct</span> <span class="n">_frame</span> <span class="o">*</span><span class="n">f_back</span><span class="p">;</span>      <span class="cm">/* previous frame, or NULL */</span>
    <span class="n">PyCodeObject</span> <span class="o">*</span><span class="n">f_code</span><span class="p">;</span>       <span class="cm">/* code segment */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_builtins</span><span class="p">;</span>       <span class="cm">/* builtin symbol table (PyDictObject) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_globals</span><span class="p">;</span>        <span class="cm">/* global symbol table (PyDictObject) */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_locals</span><span class="p">;</span>         <span class="cm">/* local symbol table (any mapping) */</span>
    <span class="n">PyObject</span> <span class="o">**</span><span class="n">f_valuestack</span><span class="p">;</span>    <span class="cm">/* points after the last local */</span>

    <span class="n">PyObject</span> <span class="o">**</span><span class="n">f_stacktop</span><span class="p">;</span>          <span class="cm">/* Next free slot in f_valuestack.  ... */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_trace</span><span class="p">;</span>          <span class="cm">/* Trace function */</span>
    <span class="kt">char</span> <span class="n">f_trace_lines</span><span class="p">;</span>         <span class="cm">/* Emit per-line trace events? */</span>
    <span class="kt">char</span> <span class="n">f_trace_opcodes</span><span class="p">;</span>       <span class="cm">/* Emit per-opcode trace events? */</span>

    <span class="cm">/* Borrowed reference to a generator, or NULL */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_gen</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">f_lasti</span><span class="p">;</span>                <span class="cm">/* Last instruction if called */</span>
    <span class="cm">/* ... */</span>
    <span class="kt">int</span> <span class="n">f_lineno</span><span class="p">;</span>               <span class="cm">/* Current line number */</span>
    <span class="kt">int</span> <span class="n">f_iblock</span><span class="p">;</span>               <span class="cm">/* index in f_blockstack */</span>
    <span class="kt">char</span> <span class="n">f_executing</span><span class="p">;</span>           <span class="cm">/* whether the frame is still executing */</span>
    <span class="n">PyTryBlock</span> <span class="n">f_blockstack</span><span class="p">[</span><span class="n">CO_MAXBLOCKS</span><span class="p">];</span> <span class="cm">/* for try and loop blocks */</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_localsplus</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>  <span class="cm">/* locals+stack, dynamically sized */</span>
<span class="p">};</span>
</pre></div>


<p>The first frame is created to execute a module's code object. CPython creates a new frame whenever it needs to execute another code object. Each frame has a reference to the previous frame. Thus, frames form a stack of frames, also known as the call stack, with the current frame sitting on top. When a function is called, a new frame is pushed on the stack. On return from the currently executing frame, CPython continues execution of the previous frame by remembering its last processed instruction. In some sense the CPython VM does nothing but constructs and executes the frames. But as we'll soon see, this summary, to put it mildly, hides some details.</p>
<h3>Threads, interpreters, runtime</h3>
<p>We've already looked at the three important concepts:</p>
<ul>
<li>a code object</li>
<li>a function object; and</li>
<li>a frame object.</li>
</ul>
<p>CPython has three more:</p>
<ul>
<li>a thread state</li>
<li>an interpreter state; and</li>
<li>a runtime state.</li>
</ul>
<h4>thread state</h4>
<p>A thread state is a data structure that contains thread-specific data including the call stack, an exception state and the debugging settings. It should not be confused with an OS thread. They're closely connected, though. Consider what happens when you use a standard <code>treading</code> module to run a function in a separate thread:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Perform an I/O-bound task&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>


<p><code>t.start()</code> actually creates a new OS thread by calling the OS function (<code>pthread_create</code> on UNIX-like systems and <code>_beginthreadex</code> on Windows). The newly created thread invokes the function from the <code>_thread</code> module that is responsible for calling the target. This function receives not only the target and the target's arguments but also a new thread state to be used within a new OS thread. An OS thread enters the evaluation loop with its own thread state, thus always having it at hand.</p>
<p>We may remember here the famous GIL (Global Interpreter Lock) that prevents multiple threads to be in the evaluation loop at the same time. The major reason for that is to protect the state of CPython from corruption without introducing more fine-grained locks. <a href="https://docs.python.org/3.9/c-api/index.html">The Python/C API Reference</a> explains the GIL clearly:</p>
<blockquote>
<p>The Python interpreter is not fully thread-safe. In order to support multi-threaded Python programs, there’s a global lock, called the global interpreter lock or GIL, that must be held by the current thread before it can safely access Python objects. Without the lock, even the simplest operations could cause problems in a multi-threaded program: for example, when two threads simultaneously increment the reference count of the same object, the reference count could end up being incremented only once instead of twice.</p>
</blockquote>
<p>To manage multiple threads, there needs to be a higher-level data structure than a thread state.</p>
<h4>interpreter and runtime states</h4>
<p>In fact, there are two of them: an interpreter state and the runtime state. The need for both may not seem immediately obvious. However, an execution of any program has at least one instance of each and there are good reasons for that.</p>
<p>An interpreter state is a group of threads along with the data specific to this group. Threads share such things as loaded modules (<code>sys.modules</code>), builtins (<code>builtins.__dict__</code>) and the import system (<code>importlib</code>). </p>
<p>The runtime state is a global variable. It stores data that is specific to a process. This includes CPython state (is it initialized or not?) and the GIL mechanism.</p>
<p>Usually, all threads of a process belong to the same interpreter. There are, however, rare cases when one may want to create a subinterpreter to isolate a group of threads. <a href="https://modwsgi.readthedocs.io/en/develop/user-guides/processes-and-threading.html#python-sub-interpreters">mod_wsgi</a>, which uses distinct interpreters to run WSGI applications, is one example. The most obvious effect of isolation is that each group of threads gets its own version of all modules including <code>__main__</code>, which is a global namespace.</p>
<p>CPython doesn't provide an easy way to create new interpreters analogues to <code>threading</code> module. The feature is supported only via Python/C API, but <a href="https://www.python.org/dev/peps/pep-0554/">this may change</a> someday.</p>
<h3>Architecture summary</h3>
<p>Let's make a quick summary of the CPython's architecture to see how everything fits together. The interpreter can be viewed as a layered structure. The following sums up what the layers are:</p>
<ol>
<li>Runtime: global CPython state of a process; includes GIL and memory allocation mechanism</li>
<li>Interpreter: group of threads and some data they share such as imported modules.</li>
<li>Thread: data specific to a single OS thread; this includes call stack.</li>
<li>Frame: element of call stack; provides a state to execute a code object.</li>
<li>Evaluation loop: executes a code object, which tells what a code block does and contains bytecode and names of variables.</li>
</ol>
<p>The layers are represented by the corresponding data structures, which we've already seen. In some cases they are not equivalent, tough. For example, the mechanism of memory allocation is implemented using global variables. It's not a part of the runtime state but certainly a part of CPython runtime layer. </p>
<h3>Conclusion</h3>
<p>In this part we've outlined what <code>python</code> does to execute a Python program. We've seen that it works in three stages: </p>
<ol>
<li>
<p>initializes Python runtime</p>
</li>
<li>
<p>compiles a source code to a module's code object; and</p>
</li>
<li>
<p>executes bytecode of the code object.</p>
</li>
</ol>
<p>The part of the interpreter that is responsible for bytecode execution is called a virtual machine. The CPython VM has several particularly important concepts: a code object, a frame object, a thread state, an interpreter state and the runtime. These data structures form a core of the CPython architecture. </p>
<p>We haven't covered a lot of things. We avoided digging into the source code. The initialization and compilation stages were completly out of our scope. Instead, we started with the broad overview of the VM. In this way, I think, we can better see the responsibilities of each stage. Now we know what CPython compiles source code to – to the code object. Next time we'll see how it does that.</p>
<p><br></p>
<p><em>If you have any questions, comments or suggestions, feel free to contact me at victor@tenthousandmeters.com</em></p>
<p><br></p>
<p><strong>Update 4 September 2020</strong>: I've made <a href="/materials/python-behind-the-scenes-a-list-of-resources/">a list of resources</a> that I've used to learn about CPython internals</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

    <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-65327549-5', 'auto');
    ga('send', 'pageview');
    </script>
</body>
</html>